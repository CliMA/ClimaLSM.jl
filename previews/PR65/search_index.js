var documenterSearchIndex = {"docs":
[{"location":"APIs/Soil/#Soil-Models","page":"Soil Models","title":"Soil Models","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Models","title":"Soil Models","text":"CurrentModule = ClimaLSM.Soil","category":"page"},{"location":"APIs/Soil/#Soil-Models-2","page":"Soil Models","title":"Soil Models","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Models","title":"Soil Models","text":"ClimaLSM.Soil.AbstractSoilModel\nClimaLSM.Soil.RichardsModel\nClimaLSM.Soil.EnergyHydrology","category":"page"},{"location":"APIs/Soil/#ClimaLSM.Soil.AbstractSoilModel","page":"Soil Models","title":"ClimaLSM.Soil.AbstractSoilModel","text":"AbstractSoilModel{FT} <: AbstractModel{FT}\n\nThe abstract type for all soil models.\n\nCurrently, we only have plans to support a RichardsModel, simulating the flow of liquid water through soil via the Richardson-Richards equation,  and a fully integrated soil heat and water model, with phase change.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLSM.Soil.RichardsModel","page":"Soil Models","title":"ClimaLSM.Soil.RichardsModel","text":"RichardsModel\n\nA model for simulating the flow of water in a porous medium by solving the Richardson-Richards Equation.\n\nparameters\nthe parameter set\ndomain\nthe soil domain, using ClimaCore.Domains\ncoordinates\nthe domain coordinates\nboundary_conditions\nthe boundary conditions, of type AbstractSoilBoundaryConditions\nsources\nA tuple of sources, each of type AbstractSoilSource\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLSM.Soil.EnergyHydrology","page":"Soil Models","title":"ClimaLSM.Soil.EnergyHydrology","text":"EnergyHydrology <: AbstractSoilModel\n\nA model for simulating the flow of water and heat  in a porous medium by solving the Richardson-Richards equation and the heat equation, including terms for phase change.\n\nparameters\nThe parameter sets\ndomain\nthe soil domain, using ClimaCore.Domains\ncoordinates\nthe domain coordinates\nrre_boundary_conditions\nthe boundary conditions for RRE, of type AbstractSoilBoundaryConditions\nheat_boundary_conditions\nthe boundary conditions for heat equation, of type AbstractSoilBoundaryConditions\nsources\nA tuple of sources, each of type AbstractSoilSource\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Functions-of-State","page":"Soil Models","title":"Soil Functions of State","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Models","title":"Soil Models","text":"ClimaLSM.Soil.volumetric_liquid_fraction\nClimaLSM.Soil.pressure_head\nClimaLSM.Soil.hydraulic_conductivity\nClimaLSM.Soil.impedance_factor\nClimaLSM.Soil.viscosity_factor\nClimaLSM.Soil.effective_saturation\nClimaLSM.Soil.matric_potential\nClimaLSM.Soil.volumetric_heat_capacity\nClimaLSM.Soil.κ_solid\nClimaLSM.Soil.κ_sat_frozen\nClimaLSM.Soil.κ_sat_unfrozen\nClimaLSM.Soil.κ_sat\nClimaLSM.Soil.κ_dry\nClimaLSM.Soil.kersten_number\nClimaLSM.Soil.relative_saturation\nClimaLSM.Soil.volumetric_internal_energy\nClimaLSM.Soil.volumetric_internal_energy_liq\nClimaLSM.Soil.temperature_from_ρe_int\nClimaLSM.Soil.thermal_conductivity","category":"page"},{"location":"APIs/Soil/#ClimaLSM.Soil.volumetric_liquid_fraction","page":"Soil Models","title":"ClimaLSM.Soil.volumetric_liquid_fraction","text":"volumetric_liquid_fraction(ϑ_l::FT, ν_eff::FT) where {FT}\n\nA pointwise function returning the volumetric liquid fraction given the augmented liquid fraction and the effective porosity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.pressure_head","page":"Soil Models","title":"ClimaLSM.Soil.pressure_head","text":"pressure_head(\n    α::FT,\n    n::FT,\n    m::FT,\n    θ_r::FT,\n    ϑ_l::FT,\n    ν_eff::FT,\n    S_s::FT,\n) where {FT}\n\nA point-wise function returning the pressure head in variably saturated soil, using the van Genuchten formulation for matric potential if the soil is not saturated, and an approximation of the positive pressure in the soil if the soil is saturated.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.hydraulic_conductivity","page":"Soil Models","title":"ClimaLSM.Soil.hydraulic_conductivity","text":" hydraulic_conductivity(K_sat::FT, m::FT, S::FT) where {FT}\n\nA point-wise function returning the hydraulic conductivity, using the van Genuchten formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.impedance_factor","page":"Soil Models","title":"ClimaLSM.Soil.impedance_factor","text":"impedance_factor(\n    f_i::FT,\n    Ω::FT\n) where {FT}\n\nReturns the multiplicative factor reducing conductivity when  a fraction of ice f_i is present.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.viscosity_factor","page":"Soil Models","title":"ClimaLSM.Soil.viscosity_factor","text":"viscosity_factor(\n    T::FT,\n    γ::FT,\n    γT_ref::FT,\n) where {FT}\n\nReturns the multiplicative factor which accounts for the temperature dependence of the conductivity.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.effective_saturation","page":"Soil Models","title":"ClimaLSM.Soil.effective_saturation","text":"effective_saturation(porosity::FT, ϑ_l::FT, θr::FT) where {FT}\n\nA point-wise function computing the effective saturation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.matric_potential","page":"Soil Models","title":"ClimaLSM.Soil.matric_potential","text":" matric_potential(α::FT, n::FT, m::FT, S::FT) where {FT}\n\nA point-wise function returning the matric potential, using the van Genuchten formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.volumetric_heat_capacity","page":"Soil Models","title":"ClimaLSM.Soil.volumetric_heat_capacity","text":"volumetric_heat_capacity(\n    θ_l::FT,\n    θ_i::FT,\n    parameters::EnergyHydrologyParameters{FT},\n) where {FT}\n\nCompute the expression for volumetric heat capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.κ_solid","page":"Soil Models","title":"ClimaLSM.Soil.κ_solid","text":"κ_solid(ν_ss_om::FT,\n        ν_ss_quartz::FT,\n        κ_om::FT,\n        κ_quartz::FT,\n        κ_minerals::FT) where {FT}\n\nComputes the thermal conductivity of the solid material in soil. The _ss_ subscript denotes that the volumetric fractions of the soil components are referred to the soil solid components, not including the pore space.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.κ_sat_frozen","page":"Soil Models","title":"ClimaLSM.Soil.κ_sat_frozen","text":"function κ_sat_frozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_ice::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated frozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.κ_sat_unfrozen","page":"Soil Models","title":"ClimaLSM.Soil.κ_sat_unfrozen","text":"function κ_sat_unfrozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_l::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated unfrozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.κ_sat","page":"Soil Models","title":"ClimaLSM.Soil.κ_sat","text":"κ_sat(\n    θ_l::FT,\n    θ_i::FT,\n    κ_sat_unfrozen::FT,\n    κ_sat_frozen::FT\n) where {FT}\n\nCompute the expression for saturated thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.κ_dry","page":"Soil Models","title":"ClimaLSM.Soil.κ_dry","text":"function κ_dry(ρp::FT,\n               ν::FT,\n               κ_solid::FT,\n               κ_air::FT;\n               a::FT = 0.053) where {FT}\n\nComputes the thermal conductivity of dry soil according to the model of Balland and Arp.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.kersten_number","page":"Soil Models","title":"ClimaLSM.Soil.kersten_number","text":"kersten_number(\n    θ_i::FT,\n    S_r::FT,\n    parameters::EnergyHydrologyParameters{FT},\n) where {FT}\n\nCompute the expression for the Kersten number, using the Balland and Arp model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.relative_saturation","page":"Soil Models","title":"ClimaLSM.Soil.relative_saturation","text":"relative_saturation(\n        θ_l::FT,\n        θ_i::FT,\n        ν::FT\n) where {FT}\n\nCompute the expression for relative saturation.  This is referred to as θ_sat in Balland and Arp's paper.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.volumetric_internal_energy","page":"Soil Models","title":"ClimaLSM.Soil.volumetric_internal_energy","text":"volumetric_internal_energy(θ_i::FT, ρc_s::FT, T::FT,\n                             parameters::EnergyHydrologyParameters{FT}) where {FT}\n\nA pointwise function for computing the volumetric internal energy of the soil, given the volumetric ice content, volumetric heat capacity, and temperature.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.volumetric_internal_energy_liq","page":"Soil Models","title":"ClimaLSM.Soil.volumetric_internal_energy_liq","text":"volumetric_internal_energy_liq(T::FT, parameters::EnergyHydrologyParameters{FT}) where {FT}\n\nA pointwise function for computing the volumetric internal energy of the liquid water in the soil, given the temperature T.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.temperature_from_ρe_int","page":"Soil Models","title":"ClimaLSM.Soil.temperature_from_ρe_int","text":"temperature_from_ρe_int(ρe_int::FT, θ_i::FT, ρc_s::FT\n                        parameters::EnergyHydrologyParameters{FT}) where {FT}\n\nA pointwise function for computing the temperature from the volumetric internal energy, volumetric ice content, and volumetric heat capacity of the soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.thermal_conductivity","page":"Soil Models","title":"ClimaLSM.Soil.thermal_conductivity","text":"thermal_conductivity(\n    κ_dry::FT,\n    K_e::FT,\n    κ_sat::FT\n) where {FT}\n\nCompute the expression for thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#Soil-Parameters","page":"Soil Models","title":"Soil Parameters","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Models","title":"Soil Models","text":"ClimaLSM.Soil.RichardsParameters\nClimaLSM.Soil.EnergyHydrologyParameters","category":"page"},{"location":"APIs/Soil/#ClimaLSM.Soil.RichardsParameters","page":"Soil Models","title":"ClimaLSM.Soil.RichardsParameters","text":"RichardsParameters{FT <: AbstractFloat}\n\nA struct for storing parameters of the RichardModel.\n\nν\nThe porosity of the soil (m^3/m^3)\nvg_α\nThe van Genuchten parameter α (1/m)\nvg_n\nThe van Genuchten parameter n\nvg_m\nThe van Genuchten parameter m\nK_sat\nThe saturated hydraulic conductivity (m/s)\nS_s\nThe specific storativity (1/m)\nθ_r\nThe residual water fraction (m^3/m^3\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLSM.Soil.EnergyHydrologyParameters","page":"Soil Models","title":"ClimaLSM.Soil.EnergyHydrologyParameters","text":"EnergyHydrologyParameters{FT <: AbstractFloat}\n\nA parameter structure for the integrated soil water and energy  equation system. In this simplest form, we assume the conductivity and volumetric heat capacity of the soil are constant.\n\nκ_dry\nThe dry soil thermal conductivity, W/m/K\nκ_sat_frozen\nThe saturated thermal conductivity of frozen soil, W/m/K\nκ_sat_unfrozen\nThe saturated thermal conductivity of unfrozen soil, W/m/K\nρc_ds\nThe volumetric heat capacity of dry soil, J/m^3/K\nν\nThe porosity of the soil (m^3/m^3)\nν_ss_om\nThe volumetric fraction of the soil solids in organic matter (m^3/m^3)\nν_ss_quartz\nThe volumetric fraction of the soil solids in quartz (m^3/m^3)\nν_ss_gravel\nThe volumetric fraction of the soil solids in gravel (m^3/m^3)\nα\nThe parameter α used in computing Kersten number, unitless\nβ\nThe parameter β used in computing Kersten number, unitless\nvg_α\nThe van Genuchten parameter α (1/m)\nvg_n\nThe van Genuchten parameter n\nvg_m\nThe van Genuchten parameter m\nK_sat\nThe saturated hydraulic conductivity (m/s)\nS_s\nThe specific storativity (1/m)\nθ_r\nThe residual water fraction (m^3/m^3\nΩ\nIce impedance factor for the hydraulic conductivity\nγ\nCoefficient of viscosity factor for the hydraulic conductivity\nγT_ref\nReference temperature for the viscosity factor\nearth_param_set\nPhysical constants and clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Methods-and-Types","page":"Soil Models","title":"Soil Methods and Types","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Models","title":"Soil Models","text":"ClimaLSM.Soil.boundary_fluxes\nClimaLSM.Soil.FluxBC\nClimaLSM.Soil.AbstractSoilSource\nClimaLSM.Soil.source!","category":"page"},{"location":"APIs/Soil/#ClimaLSM.Soil.boundary_fluxes","page":"Soil Models","title":"ClimaLSM.Soil.boundary_fluxes","text":"boundary_fluxes(bc::FluxBC, _...)\n\nA function which returns the correct boundary flux given the boundary condition type FluxBC.\n\nThis is a trivial example, but a more complex one would be e.g. Dirichlet conditions on the state, which then must be converted into a flux before being applied as a boundary condition.\n\n\n\n\n\nfunction Soil.boundary_fluxes(\n    bc::RunoffBC{FT},\n    p::ClimaCore.Fields.FieldVector,\n    t::FT,\n) where {FT}\n\nExtension of the Soil.boundary_fluxes function, which  returns the water volume boundary flux for the soil, by returning the soil infiltration (computed each step and stored in p.soil_infiltration) as a top flux, and  assuming no flux at the bottom of the soil. This is for use in an LSM.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLSM.Soil.FluxBC","page":"Soil Models","title":"ClimaLSM.Soil.FluxBC","text":"FluxBC{FT} <: AbstractSoilBoundaryConditions{FT}\n\nA simple concrete type of boundary condition, which enforces constant normal fluxes at the top and bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLSM.Soil.AbstractSoilSource","page":"Soil Models","title":"ClimaLSM.Soil.AbstractSoilSource","text":"AbstractSoilSource{FT <: AbstractFloat}\n\nAn abstract type for types of source terms for the soil equations.\n\nIn standalone mode, the only supported source type is freezing and  thawing. ClimaLSM.jl creates additional sources to include as necessary e.g. root extraction (not available in stand alone mode).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLSM.Soil.source!","page":"Soil Models","title":"ClimaLSM.Soil.source!","text":" source!(dY::ClimaCore.Fields.FieldVector,\n         src::AbstractSoilSource,\n         Y::ClimaCore.Fields.FieldVector,\n         p::ClimaCore.Fields.FieldVector\n         )::ClimaCore.Field.Field\n\nA stub function, which is extended by ClimaLSM.\n\nOnce we have the freeze thaw source function, we do not need this stub anymore.\n\n\n\n\n\nSoil.source!(dY::ClimaCore.Fields.FieldVector,\n                      src::RootExtraction{FT},\n                      Y::ClimaCore.Fields.FieldVector,\n                      p::ClimaCore.Fields.FieldVector)::ClimaCore.Fields.Field  where {FT}\n\nAn extension of the Soil.source! function,  which computes source terms for the  soil model; this method returns the water loss or gain due to roots when a plant hydraulic prognostic model is included.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM","page":"ClimaLSM","title":"ClimaLSM","text":"","category":"section"},{"location":"APIs/ClimaLSM/","page":"ClimaLSM","title":"ClimaLSM","text":"CurrentModule = ClimaLSM","category":"page"},{"location":"APIs/ClimaLSM/#LSM-Model-Types-and-methods","page":"ClimaLSM","title":"LSM Model Types and methods","text":"","category":"section"},{"location":"APIs/ClimaLSM/","page":"ClimaLSM","title":"ClimaLSM","text":"ClimaLSM.RootSoilModel\nClimaLSM.LandHydrology\nClimaLSM.make_interactions_update_aux\nClimaLSM.initialize_interactions\nClimaLSM.land_components\nClimaLSM.interaction_vars\nClimaLSM.interaction_types\nClimaLSM.interaction_domains\nClimaLSM.domain","category":"page"},{"location":"APIs/ClimaLSM/#ClimaLSM.RootSoilModel","page":"ClimaLSM","title":"ClimaLSM.RootSoilModel","text":"struct RootSoilModel{\n    FT,\n    SM <: Soil.AbstractSoilModel{FT},\n    VM <: Roots.AbstractVegetationModel{FT},\n} <: AbstractLandModel{FT}\n    soil::SM\n    vegetation::VM\nend\n\nA concrete type of land model used for simulating systems with a  vegetation and a soil component.\n\nsoil\nThe soil model to be used\nvegetation\nThe vegetation model to be used\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#ClimaLSM.LandHydrology","page":"ClimaLSM","title":"ClimaLSM.LandHydrology","text":"struct LandHydrology{\n    FT,\n    SM <: Soil.AbstractSoilModel{FT},\n    SW <: Pond.AbstractSurfaceWaterModel{FT},\n} <: AbstractLandModel{FT}\n\nA concrete type of land model used for simulating systems with a  soil and surface water component.\n\nsoil\nThe soil model\nsurface_water\nThe surface water model\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#ClimaLSM.make_interactions_update_aux","page":"ClimaLSM","title":"ClimaLSM.make_interactions_update_aux","text":"make_interactions_update_aux(land::AbstractLandModel) end\n\nMakes and returns a function which updates the interaction variables,  which are a type of auxiliary variable.\n\nThe update_aux! function returned is evaluted during the right hand side evaluation.\n\nThis is a stub which concrete types of LSMs extend.\n\n\n\n\n\nmake_interactions_update_aux(\n    land::RootSoilModel{FT, SM, RM},\n) where {FT, SM <: Soil.RichardsModel{FT}, RM <: Roots.RootsModel{FT}}\n\nA method which makes a function; the returned function  updates the auxiliary variable p.root_extraction, which is needed for both the boundary condition for the soil model and the source term (runoff) for the surface water model.\n\nThis function is called each ode function evaluation.\n\n\n\n\n\nfunction make_interactions_update_aux(\n    land::LandHydrology{FT, SM, SW},\n) where {FT, SM <: Soil.RichardsModel{FT}, SW <: Pond.PondModel{FT}}\n\nA method which makes a function; the returned function  updates the auxiliary variable p.soil_infiltration, which is needed for both the boundary condition for the soil model and the source term (runoff) for the surface water model.\n\nThis function is called each ode function evaluation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.initialize_interactions","page":"ClimaLSM","title":"ClimaLSM.initialize_interactions","text":"initialize_interactions(land::AbstractLandModel) end\n\nInitializes interaction variables, which are a type of auxiliary variable, to empty objects of the correct type for the model. \n\nInteraction variables are specified by interaction_vars, their types by interaction_types, and their spaces by interaction_spaces.  This function should be called during initialize_auxiliary step.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.land_components","page":"ClimaLSM","title":"ClimaLSM.land_components","text":"land_components(land::AbstractLandModel)\n\nReturns the component names of the land model, by calling propertynames(land).\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.interaction_vars","page":"ClimaLSM","title":"ClimaLSM.interaction_vars","text":"interaction_vars(m::AbstractModel)\n\nReturns the interaction variable symbols for the model in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.interaction_types","page":"ClimaLSM","title":"ClimaLSM.interaction_types","text":"interaction_types(m::AbstractModel)\n\nReturns the shared interaction variable types for the model in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.interaction_domains","page":"ClimaLSM","title":"ClimaLSM.interaction_domains","text":"interaction_domains(m::AbstractModel)\n\nReturns the interaction domain symbols in the form of a tuple e.g. :surface or :subsurface.\n\nThis is only required for variables shared between land submodels, and only needed for multi-component models, not standalone components. Component-specific variables should be listed as prognostic or auxiliary variables which do not require this to initialize.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.domain","page":"ClimaLSM","title":"ClimaLSM.domain","text":"domain(model::AbstractModel)\n\nReturns a symbol indicating the model's domain, e.g. :surface or :subsurface\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#Land-Hydrology","page":"ClimaLSM","title":"Land Hydrology","text":"","category":"section"},{"location":"APIs/ClimaLSM/","page":"ClimaLSM","title":"ClimaLSM","text":"ClimaLSM.infiltration_capacity\nClimaLSM.infiltration_at_point\nClimaLSM.PrognosticRunoff\nClimaLSM.RunoffBC","category":"page"},{"location":"APIs/ClimaLSM/#ClimaLSM.infiltration_capacity","page":"ClimaLSM","title":"ClimaLSM.infiltration_capacity","text":"function infiltration_capacity(\n    model::Soil.AbstractSoilModel{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::ClimaCore.Fields.FieldVector,\n) where {FT}\n\nFunction which computes the infiltration capacity of the soil based on soil characteristics, moisture levels, and pond height.\n\nDefined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.infiltration_at_point","page":"ClimaLSM","title":"ClimaLSM.infiltration_at_point","text":"infiltration_at_point(η::FT, i_c::FT, P::FT)\n\nReturns the infiltration given pond height η, infiltration capacity, and precipitation. \n\nThis is defined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLSM/#ClimaLSM.PrognosticRunoff","page":"ClimaLSM","title":"ClimaLSM.PrognosticRunoff","text":"PrognosticRunoff{FT} <: Pond.AbstractSurfaceRunoff{FT}\n\nConcrete type of Pond.AbstractSurfaceRunoff for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically.\n\nThis is paired with Soil.RunoffBC: both are used at the same time, ensuring the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#ClimaLSM.RunoffBC","page":"ClimaLSM","title":"ClimaLSM.RunoffBC","text":"RunoffBC{FT} <: Soil.AbstractSoilBoundaryConditions{FT}\n\nConcrete type of Soil.AbstractSoilBoundaryConditions for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically. This infiltration is then used to set an upper boundary condition for the soil.\n\nThis is paired with Pond.PrognosticRunoff: both are used at the same  time, ensuring that the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#RootSoilModel","page":"ClimaLSM","title":"RootSoilModel","text":"","category":"section"},{"location":"APIs/ClimaLSM/","page":"ClimaLSM","title":"ClimaLSM","text":"ClimaLSM.PrognosticSoilPressure\nClimaLSM.RootExtraction","category":"page"},{"location":"APIs/ClimaLSM/#ClimaLSM.PrognosticSoilPressure","page":"ClimaLSM","title":"ClimaLSM.PrognosticSoilPressure","text":"PrognosticSoilPressure{FT} <: Roots.AbstractRootExtraction{FT}\n\nConcrete type of Roots.AbstractRootExtraction, used for dispatch  in an LSM with both soil and plant hydraulic components.\n\nThis is paired with the source term Soil.RootExtraction:both  are used at the same time, ensuring that the water flow into the roots is extracted correctly from the soil.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#ClimaLSM.RootExtraction","page":"ClimaLSM","title":"ClimaLSM.RootExtraction","text":"RootExtraction{FT} <: Soil.AbstractSoilSource{FT}\n\nConcrete type of Soil.AbstractSoilSource, used for dispatch  in an LSM with both soil and plant hydraulic components.\n\nThis is paired with the source term Roots.PrognosticSoilPressure:both  are used at the same time, ensuring that the water flow into the roots is extracted correctly from the soil.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLSM/#BucketModel","page":"ClimaLSM","title":"BucketModel","text":"","category":"section"},{"location":"APIs/ClimaLSM/","page":"ClimaLSM","title":"ClimaLSM","text":"```@docs ClimaLSM.BucketModelParameters ClimaLSM.PrescribedAtmosphere ClimaLSM.PrescribedRadiation ClimaLSM.CoupledAtmosphere ClimaLSM.CoupledRadiation ClimaLSM.BucketModel","category":"page"},{"location":"APIs/SharedUtilities/#Shared-Utilities","page":"Shared Utilities","title":"Shared Utilities","text":"","category":"section"},{"location":"APIs/SharedUtilities/","page":"Shared Utilities","title":"Shared Utilities","text":"CurrentModule = ClimaLSM","category":"page"},{"location":"APIs/SharedUtilities/#Domains","page":"Shared Utilities","title":"Domains","text":"","category":"section"},{"location":"APIs/SharedUtilities/","page":"Shared Utilities","title":"Shared Utilities","text":"ClimaLSM.Domains.AbstractDomain\nClimaLSM.Domains.RootDomain\nClimaLSM.Domains.AbstractVegetationDomain\nClimaLSM.Domains.HybridBox\nClimaLSM.Domains.Column\nClimaLSM.Domains.Plane\nClimaLSM.Domains.Point\nClimaLSM.Domains.LSMSingleColumnDomain\nClimaLSM.Domains.coordinates","category":"page"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.AbstractDomain","page":"Shared Utilities","title":"ClimaLSM.Domains.AbstractDomain","text":"AbstractDomain{FT <:AbstractFloat}\n\nAn abstract type for domains.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.RootDomain","page":"Shared Utilities","title":"ClimaLSM.Domains.RootDomain","text":"RootDomain{FT} <: AbstractVegetationDomain{FT}\n\nDomain for a single bulk plant with roots of varying depths. The user needs to specify the depths of the root tips as wel as the heights of the compartments to be modeled within the plant. The compartment heights are expected to be sorted in ascending order.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.AbstractVegetationDomain","page":"Shared Utilities","title":"ClimaLSM.Domains.AbstractVegetationDomain","text":"AbstractVegetationDomain{FT} <: AbstractDomain{FT}\n\nAn abstract type for vegetation specific domains.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.HybridBox","page":"Shared Utilities","title":"ClimaLSM.Domains.HybridBox","text":"struct HybridBox{FT} <: AbstractDomain{FT}\n    xlim::Tuple{FT, FT}\n    ylim::Tuple{FT, FT}\n    zlim::Tuple{FT, FT}\n    nelements::Tuple{Int, Int, Int}\n    npolynomial::Int\n    periodic::Tuple{Bool, Bool}\nend\n\nA struct holding the necessary information to construct a domain, a mesh,  a 2d spectral element space (horizontal) x a 1d finite difference space  (vertical), and the resulting coordinate field.\n\nThis domain is not periodic along the z-axis. Note that  only periodic domains are supported in the horizontal.\n\nFields\n\nxlim\nDomain interval limits along x axis, in meters\nylim\nDomain interval limits along y axis, in meters\nzlim\nDomain interval limits along z axis, in meters\nnelements\nNumber of elements to discretize interval, (nx, ny,nz)\nnpolynomial\nPolynomial order for the horizontal directions\nperiodic\nFlag indicating periodic boundaries in horizontal. only true is supported\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.Column","page":"Shared Utilities","title":"ClimaLSM.Domains.Column","text":"Column{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information  to construct a domain, a mesh, a center and face space, etc. for use when a finite difference in 1D is suitable, as for a soil column model.\n\nFields\n\nzlim\nDomain interval limits, (zmin, zmax), in meters\nnelements\nNumber of elements used to discretize the interval\nboundary_tags\nBoundary face identifiers\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.Plane","page":"Shared Utilities","title":"ClimaLSM.Domains.Plane","text":"Plane{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information  to construct a domain, a mesh, a 2d spectral element space, and the resulting coordinate field.\n\nNote that only periodic domains are currently supported.\n\nFields\n\nxlim\nDomain interval limits along x axis, in meters\nylim\nDomain interval limits along y axis, in meters\nnelements\nNumber of elements to discretize interval, (nx, ny)\nperiodic\nFlags for periodic boundaries; only true is supported\nnpolynomial\nPolynomial order for both x and y\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.Point","page":"Shared Utilities","title":"ClimaLSM.Domains.Point","text":"Point{FT} <: AbstractDomain{FT}\n\nA domain for single column surface variables.\n\nFor models such as ponds, snow, roots, etc. Enables consistency  in variable initialization across all domains.\n\nFields\n\nz_sfc\nSurface elevation relative to a reference (m)\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.LSMSingleColumnDomain","page":"Shared Utilities","title":"ClimaLSM.Domains.LSMSingleColumnDomain","text":"LSMSingleColumnDomain{FT} <: AbstractDomain{FT}\n\nA mixed domain, consisting of a column domain with z-coordinates at the finite difference cell centers, and a point domain, with a single z coordinate at the top boundary of the column domain.\n\nFor use in LSM modeling, where a subsurface finite difference space  (for modeling soil hydrology and energy) and a surface space are both needed.\n\nFields\n\nsubsurface\nThe subsurface Column domain\nsurface\nThe surface Point domain\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.Domains.coordinates","page":"Shared Utilities","title":"ClimaLSM.Domains.coordinates","text":"coordinates(model::AbstractSoilModel)\n\nA extension of the coordinates function, which returns the coordinates of a model domain. \n\nThe coordinates are stored in the model because they are required in computing the right hand side. \n\n\n\n\n\ncoordinates(domain::AbstractDomain)\n\nReturns the coordinate field for the domain.\n\n\n\n\n\ncoordinates(domain::LSMSingleColumnDomain{FT}) where {FT}\n\nReturns the coordinates of the LSMSingleColumnDomain as a named tuple, with keys of subsurface and surface.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#Models","page":"Shared Utilities","title":"Models","text":"","category":"section"},{"location":"APIs/SharedUtilities/","page":"Shared Utilities","title":"Shared Utilities","text":"ClimaLSM.AbstractModel\nClimaLSM.make_ode_function\nClimaLSM.make_rhs\nClimaLSM.make_update_aux\nClimaLSM.prognostic_vars\nClimaLSM.auxiliary_vars\nClimaLSM.initialize_prognostic\nClimaLSM.initialize_auxiliary\nClimaLSM.initialize\nClimaLSM.name","category":"page"},{"location":"APIs/SharedUtilities/#ClimaLSM.AbstractModel","page":"Shared Utilities","title":"ClimaLSM.AbstractModel","text":"abstract type AbstractModel{FT <: AbstractFloat}\n\nAn abstract type for all models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SharedUtilities/#ClimaLSM.make_ode_function","page":"Shared Utilities","title":"ClimaLSM.make_ode_function","text":"make_ode_function(model::AbstractModel)\n\nReturns an ode_function that updates auxiliary variables and updates the prognostic state.\n\node_function! should be compatible with OrdinaryDiffEq.jl solvers.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.make_rhs","page":"Shared Utilities","title":"ClimaLSM.make_rhs","text":"make_rhs(model::RichardsModel)\n\nAn extension of the function make_rhs, for the Richardson- Richards equation. \n\nThis function creates and returns a function which computes the entire right hand side of the PDE for ϑ_l, and updates dY.soil.ϑ_l in place with that value.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_rhs(model::EnergyHydrology)\n\nAn extension of the function make_rhs, for the integrated soil energy and heat equations, including phase change.\n\nThis function creates and returns a function which computes the entire right hand side of the PDE for Y.soil.ϑ_l, Y.soil.θ_i, Y.soil.ρe_int,  and updates dY.soil in place with those values.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_rhs(model::BucketModel{FT}) where {FT}\n\nCreates the rhs! function for the bucket model.\n\n\n\n\n\nmake_rhs(model::AbstractModel)\n\nReturn a rhs! function that updates state variables.\n\nrhs! should be compatible with OrdinaryDiffEq.jl solvers.\n\n\n\n\n\nmake_rhs(model::RootsModel)\n\nA function which creates the rhs! function for the RootsModel. The rhs! function must comply with a rhs function of OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.make_update_aux","page":"Shared Utilities","title":"ClimaLSM.make_update_aux","text":"make_update_aux(model::RichardsModel)\n\nAn extension of the function make_update_aux, for the Richardson- Richards equation. \n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::EnergyHydrology)\n\nAn extension of the function make_update_aux, for the integrated soil hydrology and energy model.\n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::BucketModel{FT}) where {FT}\n\nCreates the update_aux! function for the BucketModel.\n\n\n\n\n\nmake_update_aux(model::AbstractModel)\n\nReturn an update_aux! function that updates auxiliary parameters p.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.prognostic_vars","page":"Shared Utilities","title":"ClimaLSM.prognostic_vars","text":"prognostic_vars(soil::RichardsModel)\n\nA function which returns the names of the prognostic variables of RichardsModel.\n\n\n\n\n\nprognostic_vars(soil::EnergyHydrology)\n\nA function which returns the names of the prognostic variables of EnergyHydrology.\n\n\n\n\n\nprognostic_vars(m::AbstractModel)\n\nReturns the prognostic variable symbols for the model in the form of a tuple.\n\n\n\n\n\nprognostic_vars(model::RootsModel)\n\nA function which returns the names of the prognostic  variables of the RootsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.auxiliary_vars","page":"Shared Utilities","title":"ClimaLSM.auxiliary_vars","text":"auxiliary_vars(soil::RichardsModel)\n\nA function which returns the names of the auxiliary variables  of RichardsModel.\n\nNote that auxiliary variables are not needed for such a simple model. We could instead compute the conductivity and matric potential within the rhs function explicitly, rather than compute and store them in the  auxiliary vector p. We did so in this case as a demonstration.\n\n\n\n\n\nauxiliary_vars(soil::EnergyHydrology)\n\nA function which returns the names of the auxiliary variables of EnergyHydrology.\n\n\n\n\n\nauxiliary_vars(m::AbstractModel)\n\nReturns the auxiliary variable symbols for the model in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.initialize_prognostic","page":"Shared Utilities","title":"ClimaLSM.initialize_prognostic","text":"initialize_prognostic(model::AbstractModel, state::Union{ClimaCore.Fields.Field, Vector{FT}})\n\nReturns a FieldVector of prognostic variables for model with the required structure, with values equal to similar(state). This assumes that all  prognostic variables are defined over the entire domain, and that all prognostic variables have the same dimension and type.\n\nIf a model has no prognostic variables, the returned FieldVector contains only an empty array.\n\nAdjustments to this - for example because different prognostic variables have different dimensions - require defining a new method.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.initialize_auxiliary","page":"Shared Utilities","title":"ClimaLSM.initialize_auxiliary","text":"initialize_auxiliary(model::AbstractModel,state::Union{ClimaCore.Fields.Field, Vector{FT}})\n\nReturns a FieldVector of auxiliary variables for model with the required structure, with values equal to similar(state). This assumes that all  auxiliary variables are defined over the entire domain, and that all auxiliary variables have the same dimension and type.\n\nIf a model has no auxiliary variables, the returned FieldVector contains only an empty array.\n\nAdjustments to this - for example because different auxiliary variables have different dimensions - require defining a new method.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.initialize","page":"Shared Utilities","title":"ClimaLSM.initialize","text":"initialize(model::AbstractModel)\n\nCreates the prognostic and auxiliary states structures, but with unset  values; constructs and returns the coordinates for the model domain. We may need to consider this default more as we add diverse components and  Simulations.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SharedUtilities/#ClimaLSM.name","page":"Shared Utilities","title":"ClimaLSM.name","text":"name(model::AbstractModel)\n\nReturns a symbol of the model component name, e.g. :soil or :vegetation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SurfaceWater/#SurfaceWater","page":"Surface Water Models","title":"SurfaceWater","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"CurrentModule = ClimaLSM.Pond","category":"page"},{"location":"APIs/SurfaceWater/#Models","page":"Surface Water Models","title":"Models","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"ClimaLSM.Pond.PondModel","category":"page"},{"location":"APIs/SurfaceWater/#ClimaLSM.Pond.PondModel","page":"Surface Water Models","title":"ClimaLSM.Pond.PondModel","text":"PondModel{FT, D, R} <: AbstractSurfaceWaterModel{FT}\n\nA stand-in model for models like the snow or river model. In  standalone mode, a prescribed soil infiltration rate  and precipitation rate control the rate of change of the pond height variable η via an ODE. In integrated LSM mode, the infiltration into the soil will be computed via a different method, and also be applied as a flux boundary condition for the soil model. \n\ndomain\nThe domain for the pond model\nrunoff\nThe runoff model for the pond model\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#Methods-and-Types","page":"Surface Water Models","title":"Methods and Types","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"ClimaLSM.Pond.PrescribedRunoff\nClimaLSM.Pond.surface_runoff","category":"page"},{"location":"APIs/SurfaceWater/#ClimaLSM.Pond.PrescribedRunoff","page":"Surface Water Models","title":"ClimaLSM.Pond.PrescribedRunoff","text":"PrescribedRunoff <:  AbstractSurfaceRunoff\n\nThe required input for driving the simple pond model: precipitation, as a function of time, soil effective saturation at a depth Δz below the surface, as a function of time, and soil parameters, which affect infiltration.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#ClimaLSM.Pond.surface_runoff","page":"Surface Water Models","title":"ClimaLSM.Pond.surface_runoff","text":"function Pond.surface_runoff(\n    runoff::PrognosticRunoff{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::ClimaCore.Fields.FieldVector,\n    t::FT,\n) where {FT}\n\nExtension of the Pond.surface_runoff function, which computes the surface runoff, for use in an LSM when the runoff is determined prognostically.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Vegetation/#Vegetation","page":"Vegetation Models","title":"Vegetation","text":"","category":"section"},{"location":"APIs/Vegetation/","page":"Vegetation Models","title":"Vegetation Models","text":"CurrentModule = ClimaLSM.Roots","category":"page"},{"location":"APIs/Vegetation/#Models","page":"Vegetation Models","title":"Models","text":"","category":"section"},{"location":"APIs/Vegetation/","page":"Vegetation Models","title":"Vegetation Models","text":"ClimaLSM.Roots.AbstractVegetationModel\nClimaLSM.Roots.RootsModel","category":"page"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.AbstractVegetationModel","page":"Vegetation Models","title":"ClimaLSM.Roots.AbstractVegetationModel","text":"AbstractVegetationModel{FT} <: AbstractModel{FT}\n\nAn abstract type for vegetation models. Concrete types include a plant hydraulics model, but future types will include multi-layer canopy models and possibly a big leaf model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.RootsModel","page":"Vegetation Models","title":"ClimaLSM.Roots.RootsModel","text":"RootsModel{FT, PS, D, RE, T, B} <: AbstractVegetationModel{FT}\n\nDefines, and constructs instances of, the RootsModel type, which is used for simulation flow of water to/from soil, along roots of different depths, along a stem, to a leaf, and ultimately being lost from the system by transpiration.  This model can be used in standalone mode by prescribing the transpiration rate and soil pressure at the root tips, or with a dynamic soil model using ClimaLSM.\n\nparameters\nParameters required by the root model\ndomain\nThe root model domain, of type AbstractVegetationDomain\nroot_extraction\nThe root extraction model, of type AbstractRootExtraction\ntranspiration\nThe transpiration model, of type AbstractTranspiration\n\n\n\n\n\n","category":"type"},{"location":"APIs/Vegetation/#Roots-Diagnostic-Variables","page":"Vegetation Models","title":"Roots Diagnostic Variables","text":"","category":"section"},{"location":"APIs/Vegetation/","page":"Vegetation Models","title":"Vegetation Models","text":"ClimaLSM.Roots.p_to_theta\nClimaLSM.Roots.theta_to_p\nClimaLSM.Roots.flow\nClimaLSM.Roots.flow_out_roots","category":"page"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.p_to_theta","page":"Vegetation Models","title":"ClimaLSM.Roots.p_to_theta","text":"p_to_theta(p::FT) where {FT}\n\nComputes the pressure (p)  given the volumetric water content (theta). Currently this is using appropriate vG parameters for loamy type soil. The pressure (MPa)  must be converted to meters (head) for use in the van Genuchten formula.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.theta_to_p","page":"Vegetation Models","title":"ClimaLSM.Roots.theta_to_p","text":"theta_to_p(theta::FT) where {FT}\n\nComputes the volumetric water content (moles/moles) given pressure (p). Currently this is using appropriate vG parameters for loamy type soil. First the head (m) is computed, and then converted to a pressure in MPa.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.flow","page":"Vegetation Models","title":"ClimaLSM.Roots.flow","text":"function flow(\n    z1::FT,\n    z2::FT,\n    p1::FT,\n    p2::FT,\n    a::FT,\n    b::FT,\n    Kmax::FT,\n) where {FT}\n\nComputes the flow of water (moles/sec)  given the height and pressures at two points. Here, a, b, andKmax` are parameters which parameterize the hydraulic conductance of the pathway along which the flow occurs.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.flow_out_roots","page":"Vegetation Models","title":"ClimaLSM.Roots.flow_out_roots","text":"Roots.flow_out_roots(\n    re::PrognosticSoilPressure{FT},\n    model::Roots.RootsModel{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::ClimaCore.Fields.FieldVector,\n    t::FT,\n)::FT where {FT}\n\nAn extension of the Roots.flow_out_roots function,  which returns the net flow of water between the roots and the soil, when both soil and plant hydraulics are modeled prognostically. This is for use in an LSM.\n\nIt is computed by summing the flow of water between roots and soil at each soil layer.\n\n\n\n\n\nflow_out_roots(\n    re::PrescribedSoilPressure{FT},\n    model::RootsModel{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::ClimaCore.Fields.FieldVector,\n    t::FT,\n)::FT where {FT}\n\nA method which computes the flow between the soil and the stem, via the roots, in the case of a standalone root model with prescribed soil pressure (in MPa) at the root tips. This assumes that the stem compartment is the first element of Y.roots.rwc.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Vegetation/#Roots-Parameters","page":"Vegetation Models","title":"Roots Parameters","text":"","category":"section"},{"location":"APIs/Vegetation/","page":"Vegetation Models","title":"Vegetation Models","text":"ClimaLSM.Roots.RootsParameters","category":"page"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.RootsParameters","page":"Vegetation Models","title":"ClimaLSM.Roots.RootsParameters","text":"RootsParameters{FT <: AbstractFloat}\n\nA struct for holding parameters of the Root Model. Eventually to be used with ClimaParameters.\n\na_root\ncontrols the shape and steepness of conductance vs. pressure curve, for roots: unitless\nb_root\ncontrols the steepness of the relative conductance vs. pressure curve, for roots: inverse MPa\na_stem\ncontrols the shape and steepness of relative conductance vs. pressure curve, for stems: unitless\nb_stem\ncontrols the steepness of the conductance vs. pressure curve, for stems: inverse MPa\nsize_reservoir_stem_moles\nthe physical size of the stem, in moles\nsize_reservoir_leaf_moles\nthe physical size of the leaves, in moles\nK_max_root_moles\nwater conductance in roots (moles/s/MPa) when pressure is zero, a maximum\nK_max_stem_moles\nwater conductance in stems (moles/s/MPa) when pressure is zero, a maximum\nearth_param_set\nPhysical Constants and other clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Vegetation/#Roots-Methods-and-Types","page":"Vegetation Models","title":"Roots Methods and Types","text":"","category":"section"},{"location":"APIs/Vegetation/","page":"Vegetation Models","title":"Vegetation Models","text":"ClimaLSM.Roots.flow_out_roots\nClimaLSM.Roots.PrescribedSoilPressure\nClimaLSM.Roots.PrescribedTranspiration\nClimaLSM.Roots.AbstractRootExtraction","category":"page"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.PrescribedSoilPressure","page":"Vegetation Models","title":"ClimaLSM.Roots.PrescribedSoilPressure","text":"PrescribedSoilPressure{FT} <: AbstractRootExtraction{FT}\n\nA concrete type used for dispatch when computing the flow_out_roots, in the case where the soil pressure at each root layer is prescribed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.PrescribedTranspiration","page":"Vegetation Models","title":"ClimaLSM.Roots.PrescribedTranspiration","text":"PrescribedTranspiration{FT} <: AbstractTranspiration{FT}\n\nA concrete type used for dispatch when computing the transpiration from the leaves, in the case where transpiration is prescribed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Vegetation/#ClimaLSM.Roots.AbstractRootExtraction","page":"Vegetation Models","title":"ClimaLSM.Roots.AbstractRootExtraction","text":"AbstractRootExtraction{FT <: AbstractFloat}\n\nAn abstract type for types representing different models of water exchange between soil and plants. Currently, only a prescribed soil pressure is supported for standalone plant hydraulics. Use within an LSM requires types defined within ClimaLSM, and include a prognostic soil pressure for models with both soil and roots.\n\n\n\n\n\n","category":"type"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/../../..\"","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The AbstractModel framework allows users to define land component models (e.g. for snow, soil, vegetation, carbon...) which can be run in standalone mode, or as part of a land surface model with many components. In order to achieve this flexibility, we require a standard interface, which is what AbstractModels provides. The interface is designed to work with an external package for the time-stepping of ODEs - we are using DifferentialEquations.jl at present - , with ClimaCore.jl, for the spatial discretization of PDEs, and with ClimaLSM.jl, for designing and running multi-component land surface models. For a developer of a new land model component, using AbstractModels as shown below is the first step towards building a model which can be run in standalone or with ClimaLSM.jl.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"This tutorial introduces some of the functionality of the AbstractModel interface functions and types. We demonstrate how to use a Model <: AbstractModel structure to define a set of equations, and explain a few core methods which must be defined for your Model type in order to run a simulation.  We use a non-land modelling system of ODEs for this purpose, to demonstrate generality. For land model components, you would follow the same principles - see the carbon tutorial for a similar example.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Future tutorials (TBD where) will show to define simple land component models and run them together using ClimaLSM.jl.","category":"page"},{"location":"generated/model_tutorial/#General-setup","page":"Using AbstractModel functionality","title":"General setup","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"We assume you are solving a system of the form of a set of PDEs or ODEs. Additional algebraic equations for can be accomodated as well, but only in addition to variables advanced using differential equations.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Spatially discretized PDEs reduce to a system of ODEs, so we can assume an ODE system in what follows without a loss of generality. When using AbstractModels, you should use ClimaCore to discretize your PDE, as applicable.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Your model defines a system of equations of the following form:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"fracd vecYd t = vecf(vecY vecx t mboxparams ldots)","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The variables that are stepped forward via a differential equation are referred to as prognostic variables, and are stored in vecY. Generically, we will speak of the functions vecf as the right hand side functions; these can be functions of the prognostic state, of space vecx, and of time t, as well as of other parameters. Note that quantities such as boundary conditions, source terms, etc, will appear within these right hand side functions.","category":"page"},{"location":"generated/model_tutorial/#Optional-auxiliary-variables","page":"Using AbstractModel functionality","title":"Optional auxiliary variables","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"It may be that there are quantities, which depend on the state vector vecY, location, time, and other parameters, which are expensive to compute (e.g. requiring solving an implicit equation) and also needed multiple times in the right hand side functions.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Denoting these variables as vecp, your equations may be rewritten as:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"fracd vecYd t = vecf(vecY vecp vecx t mboxparams ldots)","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"vecp(vecx t) = vecg(vecY(t) vecx t mboxparams ldots)","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The variables vecp at the current timestep are functions of the state, space, time, and parameters. These variables are referred to as auxiliary variables (TBD: or cache variables). Their only purpose is for storing the value of a quantity in a pre-allocated spot in memory, to avoid computing something expensive many times per time-step, or to avoid allocating memory to store each timestep. They are not a required feature, strictly speaking, and should be only used for this particular use case. A model purely consisting of algebraic equations, running in standalone mode, is not supported (vecY cannot be zero dimensional).","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"In order to define this set of equations, in a manner which is consistent with the AbstractModel interface (used by ClimaLSM.jl) and time-stepping algorithms (OrdinaryDiffEq.jl for the present), the following must be provided.","category":"page"},{"location":"generated/model_tutorial/#The-Model","page":"Using AbstractModel functionality","title":"The Model","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"All ClimaLSM component models are concrete instances of AbstractModels. The reason for grouping them in such a way is because they all have shared required functionality, as we will see, and can make use of common default behavior.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The model structure holds all of the information needed to create the full right hand side function, including parameters (which can be functions of space and time), boundary conditions, and physical equations.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The purpose of our AbstractModel interface is that it allows you to run land component models in standalone mode and in an LSM mode without a change in interface. However, we can still use this system to show how to set up a model, equations, etc.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"As a simple demonstration of use, we'll build a model now which describes the motion of a particle in the Henon-Heiles potential. This decribes a particle moving on a plane under a cubic potential energy function, and is a problem of historical and scientific interest as an example of a system exhibiting Hamiltonian chaos. To be clear, if you only want to integrate a system like this, you should not be using our AbstractModels interface, and working with OrdinaryDiffEq.jl directly!","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Let's first import some needed packages.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"using OrdinaryDiffEq: ODEProblem, solve, RK4\nusing Plots\nusing ClimaCore\nusing DifferentialEquations\nif !(\".\" in LOAD_PATH)\n    push!(LOAD_PATH, \".\")\nend\nusing ClimaLSM\nusing ClimaLSM.Domains","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Import the functions we are extending for our model:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"import ClimaLSM: name, make_rhs, prognostic_vars, prognostic_types\nimport ClimaLSM.Domains: coordinates","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"There is only one free parameter in the model, λ, so our model structure is very simple. Remember, the model should contain everything you need to create the right hand side function.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"struct HenonHeiles{FT} <: AbstractModel{FT}\n    λ::FT\nend;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"For reasons we will discuss momentarily, let's also define the name of the model:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"ClimaLSM.name(model::HenonHeiles) = :hh;","category":"page"},{"location":"generated/model_tutorial/#Right-hand-side-function","page":"Using AbstractModel functionality","title":"Right hand side function","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Here is where we need to specify the equations of motion. The prognostic variables for the Henon-Heiles system consist of two position variables (x, y), and two momentum variables (m_x, m_y, where we are using m rather than p as is typical to avoid confusion with the auxiliary vector p). The differential equations are:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"dotx = m_x","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"doty = m_y","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"dotm_x = -x -2 λ xy","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"dotm_y = -y - λ (x² - y²)","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"These equations describe Newton's 2nd law for the particle, where the force acting is minus the gradient of the potential function (the aforementioned cubic); they are derived by taking the appropriate derivatives of the Hamiltonian (in this case, total energy) function.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"We now create the function which makes the rhs! function:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"function ClimaLSM.make_rhs(model::HenonHeiles{FT}) where {FT}\n    function rhs!(dY, Y, p, t)\n        dY.hh.x[1] = Y.hh.m[1]\n        dY.hh.x[2] = Y.hh.m[2]\n        dY.hh.m[1] = -Y.hh.x[1] - FT(2) * model.λ * Y.hh.x[1] * Y.hh.x[2]\n        dY.hh.m[2] = -Y.hh.x[2] - model.λ * (Y.hh.x[1]^FT(2) - Y.hh.x[2]^FT(2))\n    end\n    return rhs!\nend;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"A couple of notes: the vector vecdY contains the evaluation of the right hand side function for each variable in vecY. It is updated in place (so no extra allocations are needed). Note that both vectors are not simple arrays. They are ClimaCore FieldVectors, which allow us to impose some organizational structure on the state while still behaving like arrays in some ways. We use the symbol returned by name(model) to create this hierarchy. There will ever only be one level to the hierarchy.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The arguments of rhs! are determined by the OrdinaryDiffEq interface, but should be fairly generic for any time-stepping algorithm. The rhs! function is only created once. If there are time-varying forcing terms appearing, for example, the forcing functions must be stored in model and passed in that way.","category":"page"},{"location":"generated/model_tutorial/#The-state-vectors-\\vec{Y}-and-\\vec{p}","page":"Using AbstractModel functionality","title":"The state vectors vecY and vecp","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"We have given the state vector vecY a particular structure, and don't expect the user to build this themselves. In order to have the structure Y (and p) correctly created, the model developer needs to define the names of the prognostic and auxiliary variables:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"ClimaLSM.prognostic_vars(::HenonHeiles) = (:x, :m);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"There are no auxiliary variables. By not defining a method for them, we are using the default (which adds no variables to p), i.e. ClimaLSM.auxiliary_vars(::HenonHeiles) = ().","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Lastly, we need to tell the interface something about the variables. What are they? Arrays? ClimaCore Fields? We have made the assumption that all variables are tied to a domain, or a set of coordinates.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"In this case, our coordinates are 2-d. Hence our coordinates are given by a vector with 2 elements. For each coordinate, both m and x are scalars with type FT:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"ClimaLSM.Domains.coordinates(model::HenonHeiles{FT}) where {FT} =\n    FT.([0.0, 0.0]);\nClimaLSM.prognostic_types(::HenonHeiles{FT}) where {FT} = (FT, FT);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"OK, let's try running a simulation now. Create a model instance, with λ = 1:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"hh = HenonHeiles{Float64}(1.0);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Create the initial state structure, using the default method:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Y, p, _ = initialize(hh);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Note that Y has the structure we planned on in our rhs! function, for x,","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Y.hh.x","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"and for m","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Y.hh.m","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Note also that p is empty:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"p.hh","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Float64[]","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Here we now update Y in place with initial conditions of our choosing.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Y.hh.x[1] = 0.0;\nY.hh.x[2] = 0.0;\nY.hh.m[1] = 0.5;\nY.hh.m[2] = 0.0;","category":"page"},{"location":"generated/model_tutorial/#Running-the-simulation","page":"Using AbstractModel functionality","title":"Running the simulation","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Create the ode_function. In our case, since we don't have any auxiliary variables to update each timestep, this is equivalent to the rhs! function, but in other models, it might involve an update_aux! step as well.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"ode_function! = make_ode_function(hh);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"From here on out, we are just using OrdinaryDiffEq.jl functions to integrate the system forward in time.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Initial and end times, timestep:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"t0 = 0.0;\ntf = 600.0;\ndt = 1.0;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"ODE.jl problem statement:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"prob = ODEProblem(ode_function!, Y, (t0, tf), p);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Solve command - we are using a fourth order Runge-Kutta timestepping scheme. ODE.jl uses adaptive timestepping, but we can still pass in a suggested timestep dt.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"sol = solve(prob, RK4(); dt = dt, reltol = 1e-6, abstol = 1e-6);","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Get the solution back, and make a plot.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"x = [sol.u[k].hh.x[1] for k in 1:1:length(sol.t)]\ny = [sol.u[k].hh.x[2] for k in 1:1:length(sol.t)]\n\nplot(x, y, xlabel = \"x\", ylabel = \"y\", label = \"\");\nsavefig(\"orbits.png\");","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"(Image: )","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"And, yes, we could be using a symplectic integrator, but that would require us to use a slightly different interface - and that isn't needed for our Clima LSM application.","category":"page"},{"location":"generated/model_tutorial/#And-now-for-some-bonus-material","page":"Using AbstractModel functionality","title":"And now for some bonus material","text":"","category":"section"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The motion of the system takes place in four dimensions, but it's hard for us to visualize. One nice way of doing so is via a Poincare section, or surface of section. The idea is that for quasiperiodic motion, which Hamiltonian dynamics result in, the orbit will repeatedly meet certain criteria, and we can look at the orbit variables when that criterion is met.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"For example, we can define our surface of section to be x = 0 dotx  0, since x is varying periodically and repeatedly passes through zero in the positive direction. We also will only look at orbits with a particular energy value, E_0.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Every time the section criterion is met, we plot (y m_y). Points on this surface provide a complete description of the orbit, because we can, with knowledge of x = 0 m_x 0 and E_0, back out the state of the system, which uniquely defines the orbit we are looking at.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"The functions below creates these initial conditions, given a value for E, λ, and y (setting m_y = 0 arbitrarily):","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"function set_ic_via_y!(Y, E, λ, y; my = 0.0, x = 0.0)\n    twiceV = λ * (x^2 + y^2 + 2 * x^2 * y - 2 / 3 * y^3)\n    mx = sqrt(2.0 * E - my^2 - twiceV)\n    Y.hh.x[1] = x\n    Y.hh.x[2] = y\n    Y.hh.m[1] = mx\n    Y.hh.m[2] = my\nend;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"This function creates similar initial conditions, but via m_y :","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"function set_ic_via_my!(Y, E, λ, my; y = 0.0, x = 0.0)\n    twiceV = λ * (x^2 + y^2 + 2 * x^2 * y - 2 / 3 * y^3)\n    mx = sqrt(2.0 * E - my^2 - twiceV)\n    Y.hh.x[1] = x\n    Y.hh.x[2] = y\n    Y.hh.m[1] = mx\n    Y.hh.m[2] = my\nend;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"This function takes initial conditions, runs an integration, and saves the values of the state on the surface of section, and then plots those points (thanks to the SciML team for creating a tutorial showing how to extract the state of the system when the section criterion is met.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"function map(Y, pl)\n    t0 = 0.0\n    tf = 4800.0\n    dt = 1.0\n    condition(u, t, integrator) = u.hh.x[1]\n    affect!(integrator) = nothing\n    cb = ContinuousCallback(\n        condition,\n        affect!,\n        nothing,\n        save_positions = (true, false),\n    )\n    prob = ODEProblem(ode_function!, Y, (t0, tf), p)\n    sol = solve(\n        prob,\n        RK4();\n        dt = dt,\n        reltol = 1e-6,\n        abstol = 1e-6,\n        callback = cb,\n        save_everystep = false,\n        save_start = false,\n        save_end = false,\n    )\n    y_section = [sol.u[k].hh.x[2] for k in 1:1:length(sol.t)]\n    my_section = [sol.u[k].hh.m[2] for k in 1:1:length(sol.t)]\n\n    scatter!(pl, y_section, my_section, label = \"\", markersize = 3, msw = 0)\nend;","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"Ok! Let's try it out:","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"E = 0.125;\nyvals = -0.35:0.05:0.35;\npl = scatter();\nfor yval in yvals\n    set_ic_via_y!(Y, E, 1.0, yval)\n    map(Y, pl)\nend;\nmyvals = [-0.42, -0.27, 0.05, 0.27, 0.42];\nfor myval in myvals\n    set_ic_via_my!(Y, E, 1.0, myval)\n    map(Y, pl)\nend;\n\nplot(pl, xlabel = \"y\", ylabel = \"m_y\");\nsavefig(\"surface.png\");","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"(Image: )","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"On a plot like this, a single orbit (indicated via point color) can be identified roughly as regular, or periodic, if it the points lie on a curve. Orbits which are chaotic fill out an area (orbits with a lot of numerical error also do...). The coexistence of these orbits arbitrarily close to each other, in the same system, is one fascinating aspect of deterministic chaos. Another fun aspect is seeing periodic orbits of different resonances. The set of cocentric curves are near a first-order resonance, meaning that every period for x (to reach zero), we see about one period in y,my space. The teal circles around them indicate a near resonant orbit of order 4.","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"","category":"page"},{"location":"generated/model_tutorial/","page":"Using AbstractModel functionality","title":"Using AbstractModel functionality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ClimaLSM.jl","page":"Home","title":"ClimaLSM.jl","text":"","category":"section"},{"location":"Contributing/#Contributing","page":"Contribution guide","title":"Contributing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Thank you for contributing to ClimaLSM! We encourage Pull Requests (PRs). Please do not hesitate to ask questions.","category":"page"},{"location":"Contributing/#Some-useful-tips","page":"Contribution guide","title":"Some useful tips","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"When you start working on a new feature branch, make sure you start from main by running: git checkout main.\nMake sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/. All exported functions and structs must be documented.\nWhen your PR is ready for review, clean up your commit history by squashing and make sure your code is current with ClimateMachine main by rebasing.","category":"page"},{"location":"Contributing/#Continuous-integration","page":"Contribution guide","title":"Continuous integration","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"After rebasing your branch, you can ask for review. Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.","category":"page"},{"location":"Contributing/#Automated-testing","page":"Contribution guide","title":"Automated testing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nTests runs the file test/runtests.jl,  using Pkg.test(). These are a mix of unit tests and fast integration tests.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"We use bors to manage merging PR's in the the ClimaLSM repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have integration test suite run on that PR, or bors r+ to try and merge the code.  Bors ensures that all integration tests for a given PR always pass before merging into main.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/../../..\"","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The AbstractModel tutorial describes how a user can run simulations of a physical system governed by differential equations. In this framework, the user must define a model type for their problem, which contains all of the information required to set up the system of equations. By extending the methods for make_rhs(model), prognostic_variables(model), etc, the information stored in the model is used to make the system of equations. Given initial conditions, these equations can then be stepped forward in time using the time-stepper of your choice (we are set up to use OrdinaryDiffEq.jl currently).","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The benefit of this framework is that it can be used for both individual components of an LSM (soil, snow, rivers, canopy biophysics, carbon...) as well as the LSM itself. Here we explain how a simple single column two component model can be set up using this software interface. Additionally, we demonstrate here the use of the auxiliary or cache variables, which were mentioned but not needed in the Henon-Heiles problem solved in the prior tutorial.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We'll first demonstrate how to set up two components in standalone mode, before spending time explaining the LSM setup. In our example, we have a component which accounts for soil hydrology via the Richardson-Richards (RR) equation.  Our second component is a surface water model without lateral flow (standing water, as in a pond). For more details on these models, and how they were set up, please feel free to look at the source code here and here. This tutorial focuses on using the AbstractModels framework to set up the equations, rather than on running simulations.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"First, let's load the required modules:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"if !(\".\" in LOAD_PATH)\n    push!(LOAD_PATH, \".\")\nend\nusing ClimaLSM\nusing ClimaLSM.Domains: LSMSingleColumnDomain, Column\nusing ClimaLSM.Soil\nusing ClimaLSM.Pond\n\nFT = Float64;","category":"page"},{"location":"generated/LSM_single_column_tutorial/#The-individual-component-models-I-Soil-Hydrology","page":"Intro to multi-component models","title":"The individual component models I - Soil Hydrology","text":"","category":"section"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The RR equation for the volumetric water content of soil is given by","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial ϑpartial t = -  (-K(ψ+z)) + S(xyz t)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"In order to solve this, one must specify:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"boundary conditions,\nrelevant parameters (closure models for K and ψ),\na domain and a spatial discretization scheme,\nadditional source terms S, if applicable,\na time-stepping algorithm,\ninitial conditions.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We make the distinction between the spatially discretized equations (for which you need parameters, boundary conditions, source terms, and domain/ discretization scheme information in order to write down and evaluate), and the simulation you want to run (for which you need the equations, initial conditions, a time span, and a time-stepping scheme in order to specify completely).","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, we'll focus on what you need to write the equations. In the design of all CliMA systems, everything you need to write the equations is stored in the model structure itself, so that we can call make_ode_function(model) and get back a function which computes the time derivative of the prognostic variables, which the ODE timestepper needs to advance the state forward in time.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"For the RR equation, we can create this as follows. First, we specify parameters:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ν = FT(0.495);\nK_sat = FT(0.0443 / 3600 / 100); # m/s\nS_s = FT(1e-3); #inverse meters\nvg_n = FT(2.0);\nvg_α = FT(2.6); # inverse meters\nvg_m = FT(1) - FT(1) / vg_n;\nθ_r = FT(0);\nsoil_ps = Soil.RichardsParameters{FT}(ν, vg_α, vg_n, vg_m, K_sat, S_s, θ_r);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Next, let's define the spatial domain and discretization:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"zmax = FT(0);\nzmin = FT(-1);\nnelems = 20;\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"And boundary conditions and source terms (none currently):","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"top_flux_bc = FT(0.0)\nbot_flux_bc = FT(0.0)\nsources = ()\nboundary_fluxes = FluxBC{FT}(top_flux_bc, bot_flux_bc);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"With this information, we can make our model:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil = Soil.RichardsModel{FT}(;\n    parameters = soil_ps,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We also can create the soil prognostic and auxiliary ClimaCore.Field.FieldVectors using the default method for initialize,","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y_soil, p_soil, coords_soil = initialize(soil);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and we can set up the ode function using the default as well,","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil_ode! = make_ode_function(soil);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"which computes, for the column domain,","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-frac z (-Kfrac(ψ+z) z)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"for each value of ϑ on the mesh of our soil_domain.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Note that the soil model does include both hydraulic K and pressure head ψ in the auxiliary vector, so the fields p_soil.soil.K and p_soil.soil.ψ are present. These are automatically updated first in each call to soil_ode!, as follows:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function soil_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t)\n         rhs!(dY, Y, p, t)\nend","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"where update_aux! updates K, and ψ, in p, in place, and rhs! computes the divergence of the Darcy flux, using the updated p, and then updates dY in place with the computed values. For this reason, the p vector does not need to be set to some initial condition consistent with Y_soil.soil.ϑ(t=0) before starting a simulation, though initial conditions must be given for Y.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Note also that we have defined methods make_rhs and make_update_aux, which only take the model as argument, and which return the functions update_aux! and rhs!, here and here.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Lastly, the coordinates returned by initialize contain the z-coordinates of the centers of the finite difference layers used for spatial discretization of the PDE.","category":"page"},{"location":"generated/LSM_single_column_tutorial/#The-individual-component-models-II-Surface-Water","page":"Intro to multi-component models","title":"The individual component models II - Surface Water","text":"","category":"section"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The pond model has a single variable, the pond height η, which satisfies the ODE:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"frac η t = -(P - I) = R","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"where P is the precipitation, I the infiltration into the soil, and R is the runoff. Note that P, I < 0 indicates flow in the -ẑ direction.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"To write down the pond equations, we need to specify","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"P\nI","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"which are akin to boundary conditions. In standalone mode,  one would need to pass in prescribed functions of time and store them inside our pond model, since again, the pond model structure must contain everything needed to make the ode function:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"precipitation(t::T) where {T} = t < T(20) ? -T(1e-5) : T(0.0) # m/s\n\ninfiltration(t::T) where {T} = -T(1e-6) #m/s\npond_model = Pond.PondModel{FT}(;\n    runoff = PrescribedRunoff{FT}(precipitation, infiltration),\n);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, PrescribedRunoff is the structure holding the prescribed driving functions for P and I.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Again we can initialize the state vector and auxiliary vectors:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y_pond, p_pond, coords_pond = initialize(pond_model);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We can make the ode function in the same way, for stepping the state forward in time:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"pond_ode! = make_ode_function(pond_model);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The pond_ode! function works in the same way as for the soil model:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function pond_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t)\n         rhs!(dY, Y, p, t)\nend","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"but the update_aux! does not alter p at all in this case. The pond model does not have auxiliary variables, so p_pond is empty.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The coordinates here are relatively meaningless - we are solving for the pond height at a point in space on the surface of the Earth, and by default this assigns a Point domain, with a coordinate of z_sfc = 0. In a simulation with horizontal resolution, the coordinates returned would be the (x,y,z=z_sfc(x,y)) coordinates of the surface, which are more useful.","category":"page"},{"location":"generated/LSM_single_column_tutorial/#An-LSM-with-pond-and-soil:","page":"Intro to multi-component models","title":"An LSM with pond and soil:","text":"","category":"section"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The LSM model must contain everything needed to write down the joint system of equations","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial etapartial t = -(P(t) - I(ϑ η P)) = R","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial ϑpartial t = -  (-K(ψ+z)) + S","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-K (ψ+z)_z = zmax   z = I(ϑ η P)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-K (ψ+z)_z = zmin   z = 00","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"These two components interact via the infiltration term I. Infiltration is a boundary condition for the soil, and affects the source term for the surface water equation. Infiltration depends on precipitation, the soil moisture state, and the pond height.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"As in the standalone cases, defining our model requires specifying","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"parameters,\ndomains, discretizations\nprecipitation,\nboundary conditions,\nsources in the soil equation, if any.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"First, let's make our LSM domain, which now contains information about the subsurface domain and the surface domain. For a single column, this means specifying the boundaries of the soil domain and the number of elements.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"lsm_domain = LSMSingleColumnDomain(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The surface domain is again just a Point with z_sfc = zmax.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"lsm_domain.surface","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaLSM.Domains.Point{Float64}(0.0)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The subsurface domain is a column from zmin to zmax:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"lsm_domain.subsurface","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaLSM.Domains.Column{Float64}((-1.0, 0.0), (20,), (:bottom, :top))","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Let's now collect the needed arguments for the soil and pond models:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil_args = (parameters = soil_ps, domain = lsm_domain.subsurface, sources = ());\nsurface_water_args = (domain = lsm_domain.surface,);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Atmospheric drivers don't \"belong\" to either component alone:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"land_args = (precip = precipitation,);\nland = LandHydrology{FT}(;\n    land_args = land_args,\n    soil_model_type = Soil.RichardsModel{FT},\n    soil_args = soil_args,\n    surface_water_model_type = Pond.PondModel{FT},\n    surface_water_args = surface_water_args,\n);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, LandHydrology is a type of AbstractModel which has a surface water model (Pond or otherwise) and a soil model (RR, or perhaps otherwise). Note that we pass in the type of the soil and surface water model - these could be more complex, e.g. a river model with lateral flow could be used in place of the Pond. We could also add in a snow component.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Now, note that we did not specify the infiltration function, like we did in standalone pond mode, nor did we specify boundary conditions for the soil model. Yet, before we stressed that the model needs to have everything required to write down and evaluate the time derivative of the ODEs. So, how does this work?","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, the LSM model constructor is given the information needed to make both the soil model and the pond model. Then, it is like running the pond and soil model in standalone mode, in series, except we have defined methods internally for computing the boundary condition and pond source term correctly, based on I, instead of using prescribed values passed in. The LSM constructor creates the correct boundary_fluxes object for the soil model, and the correct infiltration object for the pond model under the hood.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"To advance the state of the joint system (ϑ, η) from time t to time t+Δt, we must compute the infiltration at t. This value is stored in p.soil_infiltration, and reflects a proper use of the auxiliary or cache state: storing a quantity which we would rather compute once and store, rather than compute twice, once in the soil ode function, and once in the pond ode function. This guarantees the same value is used for both equations. In pseudo code, we have:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function make_update_aux(land)\n         soil_update_aux! = make_update_aux(land.soil)\n         surface_update_aux! = make_update_aux(land.surface_water)\n         interactions_update_aux! = make_update_aux(land, land.soil, land.surface_water)\n         function update_aux!(p,Y,t)\n                  surface_update_aux!(p,Y,t) # does nothing to `p`\n                  soil_update_aux!(p,Y,t) # updates p.soil.K and p.soil.ψ\n                  interactions_update_aux!(p,Y,t) # updates p.soil_infiltration\n         end\n         return update_aux!\nend","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and similarily for the rhs! functions:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function make_rhs(land)\n         soil_rhs! = make_update_aux(land.soil)\n         surface_rhs! = make_update_aux(land.surface_water)\n         function rhs!(dY,Y,p,t)\n                  surface_rhs(dY,Y,p, t), # computes dY.surface.η\n                  soil_rhs!(dY,Y,p,t) # computes dY.soil.ϑ\n         end\n         return rhs!\nend","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The ode_function! for the land model is then again just","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function ode_function!(dY, Y, p, t)\n         update_aux!(p,Y,t)\n         rhs!(dY, Y, p, t)\nend","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"In the above, we showed explicitly what occurs by hardcoding the rhs!, update_aux! with names for soil and surface_water. In reality, this is done by looping over the components of the land model, meaning that we can use the same code internally for land models with different components.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"A similar composition occurs for initializing the state itself: Calling initialize(land) does four things:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"initialize(land.soil)\ninitialize(land.surface_water)\ninitializes interaction terms, like p.soil_infiltration\nappend these into Y, p, and coords:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y, p, coords = initialize(land);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We have volumetric liquid water fraction:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(Y.soil)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:ϑ_l,)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and surface height of the pond:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(Y.surface_water)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:η,)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"as well as auxiliary variables for the soil:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p.soil)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:K, :ψ)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and nothing for surface water:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p.surface_water)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"()","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and the shared interaction term","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:soil_infiltration, :soil, :surface_water)","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and finally, coordinates - useful for visualization of solutions:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"coords.subsurface","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaCore.Geometry.ZPoint{Float64}-valued Field:\n  z: [-0.975, -0.925, -0.875, -0.825, -0.775, -0.725, -0.675, -0.625, -0.575, -0.525, -0.475, -0.425, -0.375, -0.325, -0.275, -0.225, -0.175, -0.125, -0.075, -0.025]","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and the coordinates of the surface variables:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"coords.surface","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaCore.Geometry.ZPoint{Float64}-valued Field:\n  z: [0.0]","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"And we can make the ode function as before:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"land_ode! = make_ode_function(land);","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Next up would be to set initial conditions, choose a timestepping scheme, and run your simulation.","category":"page"},{"location":"generated/LSM_single_column_tutorial/#Advantages-and-disadvantages","page":"Intro to multi-component models","title":"Advantages and disadvantages","text":"","category":"section"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Some advantages to our interface design are as follows:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"a developer only needs to learn a few concepts (rhs!, prognostic vs. aux variables, update_aux!, initialize, domains) to make a model which can be run in standalone or work with other components.\nlikewise, a user only needs to learn one interface to run all models, regardless of if they are standalone components or LSMs with multiple componnents.\nthe ode_function!is completely seperate from the timestepping scheme used, so any scheme can be used (with the exception of mixed implicit/explicit schemes, which we can't handle yet).\nalthough we wrote it here in a hardwired fashion for surface water and soil, the update_aux!, rhs!, etc. many methods for LSM models generalize to any number and mix of components. One just needs to write a new model type (e.g. BiophysicsModel <: AbstractModel for a vegetation and carbon component model) and the appropriate interaction methods for that model.\nthe order in which the components are treated in the rhs or in update aux does not matter. What matters is that auxiliary/cache variables are updated first, and within this update, interactions are updated last. We assume that the rhs! function for a component only needs the entire p and Y.component in making this statement. Similarily, updating the aux variables of a single component does not require interaction variables. Yhis is also the same as saying they can be run in standalone mode.\nthe code is also modular in terms of swapping out a simple component model for a more complex version.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Possible disadvantages to our interface design:","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Even in standalone model, variables are accessed in a nested way: Y.soil, p.soil, etc, which is excessive.\nTo accomodate the fact that some components involve PDEs, a developer for purely ODE based component does need to at least handle ClimaCore.Field.FieldVectors.\nstandalone models need to play by the rules of AbstractModels, and LSMs need to play by the rules of ClimaLSM.jl.","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"","category":"page"},{"location":"generated/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"This page was generated using Literate.jl.","category":"page"}]
}
